---
layout: post
title: logmnr工具的使用
category: oracle
---
Logmnr是分析redo和archivelog日志的工具。最近有个数据库archivelog飚得吓人，用logmnr看了下，最终定位，成功解决问题。

***<font color=red>多说两句</font>***：LOGMiner工具实际上由2个新的PL/SQL内建包和4个动态性能视图组成。  
2个内建包分别为：DBMS\_LOGMNR\_D和DBMS\_LOGMNR。  
其中：  
DBMS\_LOGMNR\_D包含以下过程：  dbms\_logmnr\_d.build()：提取数据字典信息  DBMS\_LOGMNR包含 以下过程：   add\_logfile:用来增加/剔除用于分析的日志文件  start\_logmnr:用来开启日志分析    end\_logmnr:终止分析会话，回收logminer所挪借的内存  
4个动态性能视图：  V$logmnr\_dictionary:LogMiner可能利用的数据字典消息  V$logmnr\_parameters:目前LogMiner所设定的参数消息  V$logmnr\_logs:目前用于分析的日志列表  v$logmnr\_contents：日志分析收获  

### 一、安装logmnr工具
cd $ORACLE_HOME/rdbms/admin  执行dbmslmd.sql  dbmslm.sql 这两个sql，logmnr工具安装成功。其中dbmslmd.sql用来创建DBMS\_LOGMNR\_D包，该包用来创建数据字典文件，dbmslm.sql用来创建DBMS\_LOGMNR包，该包用来分析日志文件。
***<font color=red>多说两句</font>***： 数据字典文件是可选的，如果没有它，LogMiner解释出来的语句中关于数据字典中的部分（如表名、列名等）和数值都将是16进制的形式，我们是无法理解的。创建数据字典的目的就是让LogMiner引用涉及到内部数据字典中的部分时为实际名字，不是系统内部的16进制。  举个例子：  INSERT INTO dm_dj_swry(rydm,rymc) VALUES (00005,’张三’);如果不使用数据字典，LogMiner解释出来的结果将是下面这个样子：  insert into Object#308(col#1,col#2) values(hextoraw(‘c30rte567e436’) ,hextoraw(‘4a6f686e20446f65’));  ***<font color=red>再多说两句</font>***：一般我们使用logmnr分析redo/archivelog，分2种情况：在原数据库分析或者在异数据库分析。在原数据库我们可以使用原数据库的数据字典，在异数据库分析我们必须创建被分析数据库的数据字典来辅助分析。  以下2种情况需要重新创建数据字典：  
1.我们要分析的数据库中的表有变化，影响到库的数据字典也发生变化。  
2.分析另外一个数据库文件的日志时，必须重新生成一遍被分析数据库的数据字典。 生成数据字典文件：  如果想要使用字典文件，数据库至少应该处于mount状态，然后执行dbms\_logmnr\_d.build()过程将数据字典信息提取到一个外部文件中。设置初始化参数：UTL\_FILE\_DIR并确认oracle对该目录有读写权限。这个目录用于存放dbms\_logmnr\_d.build()过程所产生的字典信息文件。  Exec dbms\_logmnr\_d.build(dictionary\_filename=>”dic.ora”,dictionary\_location=>”路径”)

### 二、添加想要分析的日志
关键语句为：  exec sys.dbms\_logmnr.add\_logfile(logfilename => '待分析文件',options => dbms\_logmnr.new);  exec sys.dbms\_logmnr.add\_logfile(logfilename => '待分析文件',options => dbms\_logmnr.addfile);  exec sys.dbms\_logmnr.add\_logfile(logfilename => '待分析文件',options => dbms\_logmnr.removefile);  实例：exec sys.dbms\_logmnr.add\_logfile(logfilename => '/u01/app/oracle/fast_recovery_area/BICE/archivelog/2017_06_21/o1\_mf\_1\_92392\_dnlo4odw\_.arc',options => dbms\_logmnr.new);  exec sys.dbms_logmnr.add\_logfile(logfilename => '/u01/app/oracle/fast\_recovery\_area/BICE/archivelog/2017\_06\_21/o1\_mf\_1\_92393\_dnlo7b5z\_.arc',options => dbms\_logmnr.addfile);  exec sys.dbms\_logmnr.add\_logfile(logfilename => '/u01/app/oracle/fast\_recovery\_area/BICE/archivelog/2017\_06\_21/o1\_mf\_1\_92394\_dnlr6p1d\_.arc',options => dbms\_logmnr.addfile);  exec sys.dbms\_logmnr.add\_logfile(logfilename => '/u01/app/oracle/fast\_recovery\_area/BICE/archivelog/2017\_06\_21/o1\_mf\_1\_92395\_dnlsdmh7\_.arc',options => dbms\_logmnr.addfile);  exec sys.dbms\_logmnr.add\_logfile(logfilename => '/u01/app/oracle/fast\_recovery\_area/BICE/archivelog/2017\_06\_21/o1\_mf\_1\_92396\_dnlsofvg\_.arc',options => dbms\_logmnr.addfile);  exec sys.dbms\_logmnr.add\_logfile(logfilename => '/u01/app/oracle/fast\_recovery\_area/BICE/archivelog/2017\_06\_21/o1\_mf\_1\_92397\_dnmfrl1j\_.arc',options => dbms\_logmnr.addfile);  exec sys.dbms\_logmnr.add\_logfile(logfilename => '/u01/app/oracle/fast\_recovery\_area/BICE/archivelog/2017\_06\_21/o1\_mf\_1\_92398\_dnmzcct1\_.arc',options => dbms\_logmnr.addfile);  exec sys.dbms\_logmnr.add\_logfile(logfilename => '/u01/app/oracle/fast\_recovery\_area/BICE/archivelog/2017\_06\_21/o1\_mf\_1\_92399\_dnnkjj8r\_.arc',options => dbms\_logmnr.addfile);  exec sys.dbms\_logmnr.add\_logfile(logfilename => '/u01/app/oracle/fast\_recovery\_area/BICE/archivelog/2017\_06\_21/o1\_mf\_1\_92400\_dno0k0t7\_.arc',options => dbms\_logmnr.addfile);  

### 三、	开始分析
exec sys.dbms\_logmnr.start\_logmnr(options => sys.dbms\_logmnr.dict\_from\_online\_catalog);exec sys.dbms\_logmnr.start\_logmnr(DictfileName=>’生成的数据字典文件’);  

### 四、查看分析结果 
select seg\_owner,count(\*) from v$logmnr\_contents group by seg\_owner;按照表用户查看数据库操作数量，定位到BICE用户，操作量异常。  SQL> select seg\_owner,count(\*) from v$logmnr\_contents group by seg\_owner;

|  SEG\_OWNER | COUNT(\*)|
| ------------- |:-------------:| 
||33451|
|SYS|24349|
|CJDF|3597313|
|SYSMAN|5251|		继续定位，定位到表级别的操作量异常，反馈给开发，问题解决，done。  SQL>  select count(\*) from v$logmnr\_contents where seg\_owner='CJDF' and sql\_redo='Unsupported' and table\_name='T\_APP120\_TEST';
 COUNT(*)  
 3248545###五、结束分析exec dbms\_logmnr.end\_logmnr;###六、功能及用途：  1．	追踪数据库的变化：可以离线的跟踪数据库的变化，而不会影响在线系统的性能。  2．	回退数据库的变化：回退特定的变化数据。  3．	优化和扩容计划：可通过分析日志文件中的数据以分析数据增长模式。  