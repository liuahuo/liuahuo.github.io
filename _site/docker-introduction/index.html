<!DOCTYPE html> <html> <head> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1"> <!-- Begin Jekyll SEO tag v2.0.0 --> <title>docker入门 - I’m Amanda</title> <meta property="og:title" content="docker入门" /> <meta name="description" content="1.什么是docker Docker是一个开源的引擎，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。提到Docker人们总会将它列为虚拟化产品，将其类比VMware产品，了解了docker运行原理和container的概念后，你会发现docker不仅可以实现虚拟化，还能应用于以下场景：" /> <meta property="og:description" content="1.什么是docker Docker是一个开源的引擎，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。提到Docker人们总会将它列为虚拟化产品，将其类比VMware产品，了解了docker运行原理和container的概念后，你会发现docker不仅可以实现虚拟化，还能应用于以下场景：" /> <link rel="canonical" href="http://localhost:4000/docker-introduction/" /> <meta property="og:url" content="http://localhost:4000/docker-introduction/" /> <meta property="og:site_name" content="I’m Amanda" /> <meta property="og:type" content="article" /> <meta property="article:published_time" content="2016-07-03T00:00:00+08:00" /> <script type="application/ld+json"> { "@context": "http://schema.org", "@type": "BlogPosting", "headline": "docker入门", "datePublished": "2016-07-03T00:00:00+08:00", "description": "1.什么是docker Docker是一个开源的引擎，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。提到Docker人们总会将它列为虚拟化产品，将其类比VMware产品，了解了docker运行原理和container的概念后，你会发现docker不仅可以实现虚拟化，还能应用于以下场景：", "url": "http://localhost:4000/docker-introduction/" } </script> <!-- End Jekyll SEO tag --> <link href="https://fonts.googleapis.com/css?family=Alfa+Slab+One|Source+Serif+Pro" rel="stylesheet"> <link rel="stylesheet" href="/css/main.css"> <link rel="canonical" href="http://localhost:4000/docker-introduction/"> <link rel="alternate" type="application/rss+xml" title="I'm Amanda" href="http://localhost:4000/feed.xml"> </head> <body> <div class="wrapper"> <div class="color-bars-header"><div class="cor-head colr-1"></div><div class="cor-head colr-2"></div><div class="cor-head colr-3"></div><div class="cor-head colr-4"></div><div class="cor-head colr-1"></div><div class="cor-head colr-2"></div><div class="cor-head colr-3"></div><div class="cor-head colr-4"></div></div> <style>.color-bars-header{font-size:0}.cor-head{width:12.5%;height:8px;display:inline-block}.colr-1{background-color:#98C1D9}.colr-2{background-color:#F3DE8A}.colr-3{background-color:#A7D3A6}.colr-4{background-color:#EB9486}@media screen and (max-width: 800px){.color-bars-header{margin: 0 -15px}}</style> <header class="site-header"> <div class="wrapper"> <a href="/"><h1 class="site-title">I'm Amanda</h1></a> <nav class="site-nav"> <a href="/" class="nav-link">首页</a> <a href="/category/" class="nav-link">分类</a> <a href="/contact/" class="nav-link">关于</a> </nav> </div> </header> </div> <div class="page-content"> <div class="wrapper"> <article class="post" itemscope itemtype="http://schema.org/BlogPosting"> <header class="post-header"> <h1 class="post-title" itemprop="name headline">docker入门</h1> <p class="post-meta"><time datetime="2016-07-03T00:00:00+08:00" itemprop="datePublished">Jul 3, 2016</time></p> </header> <div class="post-content" itemprop="articleBody"> <p>1.什么是docker<br /> Docker是一个开源的引擎，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。提到Docker人们总会将它列为虚拟化产品，将其类比VMware产品，了解了docker运行原理和container的概念后，你会发现docker不仅可以实现虚拟化，还能应用于以下场景：</p> <ul> <li>应用的打包和发布</li> <li>部署和调整数据库或其他应用</li> <li>标准化开发、测试环境</li> </ul> <p>2.什么是container<br /> <img src="/images/docker-introduction/container.jpg" alt="container" /> <br /> VMs将整个操作系统运行在虚拟的硬件平台上，提供完整的运行环境给应用程序。对比VMs来看Containers，Container和普通的虚拟机Image相比, 最大的区别是它并不包含操作系统内核，也就是省掉了GuestOS这一层，直接在Host上加载运行应用程序。<br /> 为什么Container能够直接在host上直接加载运行程序呢？这个和linux操作系统特性密切相关。 首先先普及几个基础知识：</p> <ul> <li>AUFS（Another Union File System）AUFS (AnotherUnionFS) 是一种 Union FS, 简单来说就是支持将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)的文件系统。Docker 在 AUFS 上构建的 container image 就使用了这种特性，接下来从启动 container 中的 linux 为例来介绍 docker 对AUFS特性的运用。</li> </ul> <p>典型的linux启动需要2个FS：bootfs+rootfs。<br /> bootfs (boot file system) 主要包含 bootloader 和 kernel, bootloader主要是引导加载kernel, 当boot成功后 kernel被加载到内存中后 bootfs就被umount了。<br /> rootfs (root file system) 包含的就是典型 Linux 系统中的 /dev, /proc,/bin, /etc 等标准目录和文件。<br /> 对于不同的linux发行版, bootfs基本是一致的, 但rootfs会有差别, 因此不同的发行版可以公用bootfs。</p> <ul> <li>container和image 典型的Linux在启动后，首先将 rootfs 设置为 readonly, 进行一系列检查, 然后将其切换为 “readwrite” 供用户使用。<br /> 在Docker中，初始化时也是将 rootfs 以readonly方式加载并检查，然而接下来利用 union mount 的方式将一个readwrite 文件系统挂载在 readonly 的rootfs之上，并且允许再次将下层的 FS(file system) 设定为readonly 并且向上叠加, 这样一组readonly和一个writeable的结构构成一个container的运行时态, 每一个FS被称作一个FS层。如下图:<br /> <img src="/images/docker-introduction/container.png" alt="container" /><br /> 得益于AUFS的特性, 每一个对readonly层文件/目录的修改都只会存在于上层的writeable层中。这样由于不存在竞争,多个container可以共享readonly的FS层。 所以Docker将readonly的FS层称作 “image” - 对于container而言整个rootfs都是read-write的，但事实上所有的修改都写入最上层的writeable层中, image不保存用户状态，只用于模板、新建和复制使用。<br /> <img src="/images/docker-introduction/container-image.png" alt="container" /><br /> 上层的image依赖下层的image，因此Docker中把下层的image称作父image，没有父image的image称作base image。因此想要从一个image启动一个container，Docker会先加载这个image和依赖的父images以及base image，用户的进程运行在writeable的layer中。所有parent image中的数据信息以及 ID、网络和lxc管理的资源限制等具container 的配置，构成一个Docker概念上的container。如下图:<br /> <img src="/images/docker-introduction/container-image2.png" alt="container" /></li> </ul> <p>3.container资源管理<br /> Cgroups（control groups） 实现了对资源的配额和度量。cgroups 的使用非常简单，提供类似文件的接口，在 /cgroup目录下新建一个 文件夹即可新建一个group，在此文件夹中新建task文件，并将pid写入该文件，即可实现对该进程的资源控制。<br /> 在安装docker前，已经安装了cgroup，所以进入到/sys/fs/cgroup目录下，可以看到cgroup可以限制的资源目录：<br /> [root@localhost cgroup]# pwd<br /> /sys/fs/cgroup<br /> [root@localhost cgroup]# ls blkio cpu cpuacct cpu,cpuacct cpuset devices freezer hugetlb memory net_cls perf_event systemd<br /> groups可以限制blkio、cpu、cpuacct、cpuset、devices、freezer、memory、net_cls、ns九大子系统的资源，以下是每个子系统的详细说明：</p> <div class="highlighter-rouge"><pre class="highlight"><code>- blkio 这个子系统设置限制每个块设备的输入输出控制。例如:磁盘，光盘以及usb等等。
- cpu 这个子系统使用调度程序为cgroup任务提供cpu的访问。
- cpuacct 产生cgroup任务的cpu资源报告。
- cpuset 如果是多核心的cpu，这个子系统会为cgroup任务分配单独的cpu和内存。
- devices 允许或拒绝cgroup任务对设备的访问。
- freezer 暂停和恢复cgroup任务。
- memory 设置每个cgroup的内存限制以及产生内存资源报告。
- net_cls 标记每个网络包以供cgroup方便使用。
- ns 名称空间子系统。
</code></pre></div> <p>以memory(内存)为例：system.slice目录里已经自动生成了docker相关的文件夹：<br /> docker-c549b04fd139dc128d9e74dd05c6bc05526194ab3e60137a316b36c3fb04ba78.scope——这个是 docker启动着的container的资源管理目录<br /> docker.service——这个是docker的资源管理目录<br /> 打开tasks文件，可以看到里面有被管理的进程id号<br /> <img src="/images/docker-introduction/task.png" alt="container" /> <br /> 目录中各个文件的作用如下：<br /> <img src="/images/docker-introduction/folder-function.png" alt="container" /></p> </div> </article> <!----> <div id="disqus_thread"></div> <script defer> (function() { var d = document, s = d.createElement('script'); s.src = '//webjeda-demo.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); </script> <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript> <!----> <!--<h2> 分类 </h2> <ul class="category-list"> <li style="background-color: #444"> <a href="/categories/docker"> docker (4) </a> </li> <li> <a href="/categories/linux"> linux (1) </a> </li> <li> <a href="/categories/git"> git (1) </a> </li> </ul>--> </div> </div> <div class="wrapper"> <footer class="site-footer"> <div class="wrapper"> </div> </footer> <div class="color-bars-header"><div class="cor-head colr-1"></div><div class="cor-head colr-2"></div><div class="cor-head colr-3"></div><div class="cor-head colr-4"></div><div class="cor-head colr-1"></div><div class="cor-head colr-2"></div><div class="cor-head colr-3"></div><div class="cor-head colr-4"></div></div> </div> <!-- Google Analytics Tracking code --> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','//www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-83979019-1', 'auto'); ga('send', 'pageview'); </script> </body> </html>
